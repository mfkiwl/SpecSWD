#include <array>
#include <complex>

typedef std::complex<float> crealw;
typedef std::complex<double> dcmplx;

namespace specswd
{

// only valid for frequency range [0.01,100]
const int NSLS = 5;
std::array<double,NSLS> y_sls_ref = {1.93044501, 1.64217132, 1.73606189, 1.42826439, 1.66934129};
std::array<double,NSLS> w_sls_ref = {4.71238898e-02, 6.63370885e-01, 9.42477796e+00, 1.14672436e+02,1.05597079e+03};


/**
 * @brief reset reference SLS model
 * 
 * @param w_sls new refernce w_sls, shape(NSLS)
 * @param y_sls new refernce y_sls, shape(NSLS)
 */
void 
reset_ref_Q_model(const double *w_sls, const double *y_sls)
{
    for(int i = 0; i < NSLS; i ++) {
        w_sls_ref[i] = w_sls[i];
        y_sls_ref[i] = y_sls[i];
    }
}

/**
 * @brief correct y from reference model to target model
 * @param Q target Q 
 * @param y_sls reference y_sls parameters
 * @param w_sls reference w_sls
 */
static void 
get_Q_sls_model(float Q,double *y_sls,double *w_sls)
{
    double dy[NSLS];
    double y[NSLS];
    for(int i = 0; i < NSLS; i ++) {
        y[i] = y_sls_ref[i] / Q; 
    }
    dy[0] = 1. + 0.5 * y[0];
    for(int i = 1; i < NSLS; i ++) {
        dy[i] = dy[i-1] + (dy[i-1] - 0.5) * y[i-1] + 0.5 * y[i];
    }

    // copy to y_sls/w_sls
    for(int i = 0; i < NSLS; i ++) {
        w_sls[i] = w_sls_ref[i];
        y_sls[i] = dy[i] * y[i];
    }
}

/**
 * @brief get SLS Q terms on the elastic modulus
 * 
 * @param freq current frequency
 * @param Q Q value 
 * @return s modulus factor  mu = mu * s 
 */
crealw get_sls_modulus_factor(float freq,float Q)
{
    double y_sls[NSLS], w_sls[NSLS];
    double om = 2 * M_PI * freq;
    const dcmplx I = {0.,1.};

    get_Q_sls_model(Q,y_sls,w_sls);
    dcmplx s {};
    for(int j = 0; j < NSLS; j ++) {
        s += I * om * y_sls[j] / (w_sls[j] + I * om);
    }

    return (crealw)(s + 1.);
}

/**
 * @brief Get the Q factor and derivative for SLS model
 * 
 * @param freq frequency 
 * @param Q current Q
 * @param s modulus factor  mu = mu * s 
 * @param dsdqi Q^{-1} derivative ds / dQi
 */
void 
get_sls_Q_derivative(float freq,float Q,crealw &s,crealw &dsdqi)
{
    double dy[NSLS],dd_dqi[NSLS];
    double y[NSLS];
    const dcmplx I = {0.,1.};
    double om = 2 * M_PI * freq;

    // compute corrector
    for(int i = 0; i < NSLS; i ++) {
        y[i] = y_sls_ref[i] / Q; 
    }
    dy[0] = 1. + 0.5 * y[0];
    for(int i = 1; i < NSLS; i ++) {
        dy[i] = dy[i-1] + (dy[i-1] - 0.5) * y[i-1] + 0.5 * y[i];
    }

    dd_dqi[0] = 0.5 * y_sls_ref[0];
    for(int i = 1; i < NSLS; i ++) {
        dd_dqi[i] = dd_dqi[i-1] + (dy[i-1] - 0.5) * y_sls_ref[i-1] + dd_dqi[i-1] * y[i-1] +  0.5 * y_sls_ref[i];
    }

    // sum together
    dcmplx s1{},dsdqi1{};
    s1 = 0.; dsdqi1 = 0.;
    for(int i = 0; i < NSLS; i ++) {
        s1 += I * om * y[i] * dy[i]/ (w_sls_ref[i] + I * om);

        // y' = delta * y 
        // dy'/dqi = d delta /dqi * y + delta * dy/dqi
        double dyp_dqi = dd_dqi[i] * y[i] + dy[i] * y_sls_ref[i];
        dsdqi1 += I * om * dyp_dqi / (w_sls_ref[i] + I * om);
    }

    s = (crealw)(s1 + 1.);
    dsdqi = dsdqi1;
}

static int Index(int m,int n)
{
    if(m > n) {
        std::swap(m,n);
    }
    int idx = m * 6 + n - (m * (m + 1)) / 2;

    return idx;
}

/**
 * @brief only set Qkappa and Qmu to C21 
 * @see Carcione and Cavallini (1995d), delta = 2, M3 = M4 = M2 -> Qmu
 */
static void 
C21_iso_(crealw Qk_fac,crealw Qmu_fac,crealw __restrict *c21)
{
    // get kappa and mu by using average
    #define C(p,q) c21[Index(p,q)]
    crealw eps = (1.0f/3.0f) * (C(0,0) + C(1,1) + C(2,2));
    crealw mu = (1.0f/3.0f) * (C(3,3) + C(4,4) + C(5,5));
    crealw kappa = eps - (float)(4. / 3.) * mu;

    // add back to c21
    for(int i = 0; i < 3; i ++) {
        C(i,i) = C(i,i) - eps + kappa * Qk_fac + (float)(4./3.) * mu * Qmu_fac;
    }
    for(int i = 0; i < 3; i ++) {
        for(int j = i + 1; j < 3; j ++) {
            C(i,j) = C(i,j) - eps + kappa * Qk_fac + 2.0f* mu * (1.0f - 1.0f/3.0f * Qmu_fac);
        }
    }

    for(int i = 3; i < 6; i ++) C(i,i) *= Qmu_fac;

    #undef C
}

static void 
C21_iso_deriv_(const crealw *Qfac, const crealw *dQfac,
                const float *c21,
                crealw *__restrict dCC21_dc,
                crealw *__restrict dCC21_dQi)
{
    // set derivatives to zero 
    for(int i = 0; i < 21 * 2; i ++) {
        dCC21_dc[i] = 0.;
        dCC21_dQi[i] = 0.;  
    }

    // get kappa and mu fac/dfac 
    dcmplx Qk_fac = Qfac[0], Qmu_fac = Qfac[1];
    dcmplx dQk_fac = dQfac[0], dQmu_fac = dQfac[1];

    // compute derivatives
    // auto generated by sympy
    #define SETDC(i,j,a) dCC21_dc[i*21+j] = (crealw) (a)
    #define SETDQ(i,j,b) dCC21_dQi[i*2+j] = (crealw) (b)
    #define C(p,q) c21[Index(p,q)]
    SETDC(0,0,(1.0/3.0)*Qk_fac + 2.0/3.0);
    SETDC(0,6,(1.0/3.0)*Qk_fac - 1.0/3.0);
    SETDC(0,11,(1.0/3.0)*Qk_fac - 1.0/3.0);
    SETDC(0,15,-4.0/9.0*Qk_fac + (4.0/9.0)*Qmu_fac);
    SETDC(0,18,-4.0/9.0*Qk_fac + (4.0/9.0)*Qmu_fac);
    SETDC(0,20,-4.0/9.0*Qk_fac + (4.0/9.0)*Qmu_fac);
    SETDC(1,0,(1.0/3.0)*Qk_fac - 1.0/3.0);
    SETDC(1,1,1);
    SETDC(1,6,(1.0/3.0)*Qk_fac - 1.0/3.0);
    SETDC(1,11,(1.0/3.0)*Qk_fac - 1.0/3.0);
    SETDC(1,15,-4.0/9.0*Qk_fac - 2.0/9.0*Qmu_fac + 2.0/3.0);
    SETDC(1,18,-4.0/9.0*Qk_fac - 2.0/9.0*Qmu_fac + 2.0/3.0);
    SETDC(1,20,-4.0/9.0*Qk_fac - 2.0/9.0*Qmu_fac + 2.0/3.0);
    SETDC(2,0,(1.0/3.0)*Qk_fac - 1.0/3.0);
    SETDC(2,2,1);
    SETDC(2,6,(1.0/3.0)*Qk_fac - 1.0/3.0);
    SETDC(2,11,(1.0/3.0)*Qk_fac - 1.0/3.0);
    SETDC(2,15,-4.0/9.0*Qk_fac - 2.0/9.0*Qmu_fac + 2.0/3.0);
    SETDC(2,18,-4.0/9.0*Qk_fac - 2.0/9.0*Qmu_fac + 2.0/3.0);
    SETDC(2,20,-4.0/9.0*Qk_fac - 2.0/9.0*Qmu_fac + 2.0/3.0);
    SETDC(3,3,1);
    SETDC(4,4,1);
    SETDC(5,5,1);
    SETDC(6,0,(1.0/3.0)*Qk_fac - 1.0/3.0);
    SETDC(6,6,(1.0/3.0)*Qk_fac + 2.0/3.0);
    SETDC(6,11,(1.0/3.0)*Qk_fac - 1.0/3.0);
    SETDC(6,15,-4.0/9.0*Qk_fac + (4.0/9.0)*Qmu_fac);
    SETDC(6,18,-4.0/9.0*Qk_fac + (4.0/9.0)*Qmu_fac);
    SETDC(6,20,-4.0/9.0*Qk_fac + (4.0/9.0)*Qmu_fac);
    SETDC(7,0,(1.0/3.0)*Qk_fac - 1.0/3.0);
    SETDC(7,6,(1.0/3.0)*Qk_fac - 1.0/3.0);
    SETDC(7,7,1);
    SETDC(7,11,(1.0/3.0)*Qk_fac - 1.0/3.0);
    SETDC(7,15,-4.0/9.0*Qk_fac - 2.0/9.0*Qmu_fac + 2.0/3.0);
    SETDC(7,18,-4.0/9.0*Qk_fac - 2.0/9.0*Qmu_fac + 2.0/3.0);
    SETDC(7,20,-4.0/9.0*Qk_fac - 2.0/9.0*Qmu_fac + 2.0/3.0);
    SETDC(8,8,1);
    SETDC(9,9,1);
    SETDC(10,10,1);
    SETDC(11,0,(1.0/3.0)*Qk_fac - 1.0/3.0);
    SETDC(11,6,(1.0/3.0)*Qk_fac - 1.0/3.0);
    SETDC(11,11,(1.0/3.0)*Qk_fac + 2.0/3.0);
    SETDC(11,15,-4.0/9.0*Qk_fac + (4.0/9.0)*Qmu_fac);
    SETDC(11,18,-4.0/9.0*Qk_fac + (4.0/9.0)*Qmu_fac);
    SETDC(11,20,-4.0/9.0*Qk_fac + (4.0/9.0)*Qmu_fac);
    SETDC(12,12,1);
    SETDC(13,13,1);
    SETDC(14,14,1);
    SETDC(15,15,Qmu_fac);
    SETDC(16,16,1);
    SETDC(17,17,1);
    SETDC(18,18,Qmu_fac);
    SETDC(19,19,1);
    SETDC(20,20,Qmu_fac);

    SETDQ(0,0,((1.0/3.0)*C(0,0)*1. + (1.0/3.0)*C(1,1)*1. + (1.0/3.0)*C(2,2)*1. - 4.0/9.0*C(3,3)*1. - 4.0/9.0*C(4,4)*1. - 4.0/9.0*C(5,5)*1.) * dQk_fac);
    SETDQ(0,1,((4.0/9.0)*C(3,3)*1. + (4.0/9.0)*C(4,4)*1. + (4.0/9.0)*C(5,5)*1.) * dQmu_fac);
    SETDQ(1,0,((1.0/3.0)*C(0,0)*1. + (1.0/3.0)*C(1,1)*1. + (1.0/3.0)*C(2,2)*1. - 4.0/9.0*C(3,3)*1. - 4.0/9.0*C(4,4)*1. - 4.0/9.0*C(5,5)*1.) * dQk_fac);
    SETDQ(1,1,(-2.0/9.0*C(3,3)*1. - 2.0/9.0*C(4,4)*1. - 2.0/9.0*C(5,5)*1.) * dQmu_fac);
    SETDQ(2,0,((1.0/3.0)*C(0,0)*1. + (1.0/3.0)*C(1,1)*1. + (1.0/3.0)*C(2,2)*1. - 4.0/9.0*C(3,3)*1. - 4.0/9.0*C(4,4)*1. - 4.0/9.0*C(5,5)*1.) * dQk_fac);
    SETDQ(2,1,(-2.0/9.0*C(3,3)*1. - 2.0/9.0*C(4,4)*1. - 2.0/9.0*C(5,5)*1.) * dQmu_fac);
    SETDQ(6,0,((1.0/3.0)*C(0,0)*1. + (1.0/3.0)*C(1,1)*1. + (1.0/3.0)*C(2,2)*1. - 4.0/9.0*C(3,3)*1. - 4.0/9.0*C(4,4)*1. - 4.0/9.0*C(5,5)*1.) * dQk_fac);
    SETDQ(6,1,((4.0/9.0)*C(3,3)*1. + (4.0/9.0)*C(4,4)*1. + (4.0/9.0)*C(5,5)*1.) * dQmu_fac);
    SETDQ(7,0,((1.0/3.0)*C(0,0)*1. + (1.0/3.0)*C(1,1)*1. + (1.0/3.0)*C(2,2)*1. - 4.0/9.0*C(3,3)*1. - 4.0/9.0*C(4,4)*1. - 4.0/9.0*C(5,5)*1.) * dQk_fac);
    SETDQ(7,1,(-2.0/9.0*C(3,3)*1. - 2.0/9.0*C(4,4)*1. - 2.0/9.0*C(5,5)*1.) * dQmu_fac);
    SETDQ(11,0,((1.0/3.0)*C(0,0)*1. + (1.0/3.0)*C(1,1)*1. + (1.0/3.0)*C(2,2)*1. - 4.0/9.0*C(3,3)*1. - 4.0/9.0*C(4,4)*1. - 4.0/9.0*C(5,5)*1.) * dQk_fac);
    SETDQ(11,1,((4.0/9.0)*C(3,3)*1. + (4.0/9.0)*C(4,4)*1. + (4.0/9.0)*C(5,5)*1.) * dQmu_fac);
    SETDQ(15,1,(C(3,3)*1.) * dQmu_fac);
    SETDQ(18,1,(C(4,4)*1.) * dQmu_fac);
    SETDQ(20,1,(C(5,5)*1.) * dQmu_fac);

    #undef C 
    #undef SETDC
    #undef SETDQ
}

/**
 * @brief set C21 attenuation model
 * @param freq frequency
 * @param Qm Q values
 * @param nQmodel number of Q values
 * @param[inout] c21 real C21 modulus shape(21), return complex modulus
 * @param funcid function id, default 1
 */
void get_C21_att(float freq,const float *Qm,int nQmodel,
                crealw __restrict *c21,int funcid)
{
    // get all sls factor
    std::array<crealw,21> Qfac;
    for(int im = 0; im < nQmodel; im ++) {
        Qfac[im] = get_sls_modulus_factor(freq,Qm[im]);
    }

    // choose sls factor
    switch (funcid)
    {
    case 1:
        C21_iso_(Qfac[0],Qfac[1],c21);
        break;
    
    default:
        printf("not implemented!\n");
        exit(1);
        break;
    }
}

/**
 * @brief compute derivatives of C21 att model
 * @param freq frequency
 * @param Qm Q values
 * @param C21 C21 model
 * @param nQmodel number of Q values
 * @param dCC21_dc derivative of complex c21 to real c21, shape (21,21)
 * @param dCC21_dQi derivative of complex c21 to Qi, shape (21,nQmodel)
 * @param funcid function id, default 1
 */
void get_C21_deriv(float freq,const float *Qm,int nQmodel,
                    const float *C21,
                    crealw *__restrict dCC21_dc,
                    crealw *__restrict dCC21_dQi,
                    int funcid)
{
    // get all sls factor
    std::array<crealw,21> Qfac,dQfac;
    for(int im = 0; im < nQmodel; im ++) {
        get_sls_Q_derivative(freq,Qm[im],Qfac[im],dQfac[im]);
    }

    switch (funcid)
    {
    case 1:
        C21_iso_deriv_(Qfac.data(),dQfac.data(),C21,dCC21_dc,dCC21_dQi);
        break;
    
    default:
        printf("not implemented!\n");
        exit(1);
        break;
    }
}

} // namespace specswd

