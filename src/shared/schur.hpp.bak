#ifndef SPECSWD_SCHUR_H_
#define SPECSWD_SCHUR_H_

#include <Eigen/Core>
#include <Eigen/Eigenvalues>

#ifdef SPECSWD_EGN_DOUBLE
typedef double realw;
#define LAPACKE_REAL(name) LAPACKE_d ## name
#define LAPACKE_CMPLX(name) LAPACKE_z ## name
#define LCREALW lapack_complex_double
 
#else
typedef float realw;
#define LAPACKE_REAL(name) LAPACKE_s ## name
#define LAPACKE_CMPLX(name) LAPACKE_c ## name
#define LCREALW lapack_complex_float
#endif

typedef std::complex<realw> crealw; 


namespace specswd {

/**
 * @brief solve eigenvectors from Hessenburg form (A - w[i] B) (Z.H @ x_i) = 0
 * 
 * @tparam T data type, default is float
 * @param A triangular matrix A
 * @param B triangular matrix A
 * @param Z Z matrix, unitary
 * @param w eigenvalues w[i] = A(i,i) / B(i,i)
 * @param v right eigenvectors
 */
template<typename T = float >  void
solve_regn_triangular(
    const Eigen::MatrixX<T> &A, 
    const Eigen::MatrixX<T> &B,
    const Eigen::MatrixX<T> &Z,
    const Eigen::VectorX<T> &w,
    Eigen::MatrixX<T> &v
)
{
    using Eigen::indexing::seq;
    using Eigen::indexing::all;
    int n = A.rows();
    for (int i = 0; i < n; i ++) {
        T e = w[i];

        // set constants
        v(seq(i+1,n-1),i).setZero();
        v(i,i) = 1.;

        // backward substitution
        for(int j = i-1; j >=0; j --) {
            auto idx = seq(j+1,i);
            T s = (A(j,idx) - e * B(j,idx)) * v(idx,i);
            T diag = A(j,j) - e * B(j,j);
            v(j,i) = std::abs(diag) < 1.0e-12 ? 0. : -s / diag;
        }
    }
    v = Z * v;

    // normalize
    for(int i = 0; i < n; i ++) {
        T s = v(all,i).norm();
        v(all,i) /= s;
    }
}

/**
 * @brief solve left eigenvectors from Hessenburg form (A - w[i] B).H (Q.H @ y_i) = 0
 * 
 * @tparam T data type, default is float
 * @param A triangular matrix A
 * @param B triangular matrix A
 * @param Q Q matrix, unitary
 * @param w eigenvalues w[i] = A(i,i) / B(i,i)
 * @param v left eigenvectors
 */
template<typename T>  void
solve_legn_triangular(
    const Eigen::MatrixX<T> &A, 
    const Eigen::MatrixX<T> &B,
    const Eigen::MatrixX<T> &Q,
    const Eigen::VectorX<T> &w,
    Eigen::MatrixX<T> &v
)
{
    using Eigen::indexing::seq;
    using Eigen::indexing::all;
    int n = A.rows();
    for (int i = 0; i < n; i ++) {
        T e = w[i];

        // set constants
        v(seq(0,i-1),i).setZero();
        v(i,i) = 1.;

        // forward substitution
        for(int j = i + 1; j < n; j ++) {
            auto idx = seq(i,j-1);
            T diag{}, s{};
            if constexpr(std::is_same_v<T,float> ||std::is_same_v<T,double> ) {
                diag = A(j,j) - e  * B(j,j);
                s = ((A(idx,j) - e * B(idx,j)).array()
                     * v(idx,i).array()).sum();
            }
            else {
                diag = std::conj(A(j,j) - e  * B(j,j));
                s = ((A(idx,j) - e * B(idx,j)) * v(idx,i)).array().conjugate().sum();
            }
            v(j,i) = std::abs(diag) < 1.0e-12 ? 0 : -s / diag;
        }
    }
    v = Q * v;

    // normalize
    for(int i = 0; i < n; i ++) {
        T s = v(all,i).norm();
        v(all,i) /= s;
    }
}

/**
 * @brief compute generalized eigenvalues/eigenvectors and schur decomposition for A x = w B x
 * @note all matrices used are column major
 * 
 * @tparam COMMTP compute type, double/complex<double>
 * @tparam SAVETP save type, float/complex<float>
 * @param A,B two matrices, type = COMMTP, shape(n,n)
 * @param w  eigenvalues, shape(n) 
 * @param vr left eigenvectors, shape(n,n)
 * @param vl right eigenvectors shape(n,n)
 * @param Qmat,Zmat,Smat,Spmat QZ matrix, where A = Q @ S @ Z.H, B = Q @ S' @ Z.H
 * @param compute_left_egn if true also compute left eigenvectors
 */
template<typename COMMTP=double,typename SAVETP=float>  void
schur_qz(
    Eigen::MatrixX<COMMTP> &A, 
    Eigen::MatrixX<COMMTP> &B,
    Eigen::ArrayX<COMMTP> &w,
    COMMTP *__restrict vr,
    COMMTP *__restrict vl, 
    std::vector<SAVETP> &Qmat,
    std::vector<SAVETP> &Zmat,
    std::vector<SAVETP> &Smat,
    std::vector<SAVETP> &Spmat,
    bool compute_left_egn = false
)
{
    static_assert(std::is_same_v<SAVETP,float> || 
                    std::is_same_v<SAVETP,std::complex<float>>);

    // allocate Q,Z matrix to compute
    int ng = A.rows();
    Eigen::MatrixX<COMMTP> Q(ng,ng),Z(ng,ng);

    // resize all matrices
    Qmat.resize(ng*ng); Zmat.resize(ng*ng);
    Smat.resize(ng*ng); Spmat.resize(ng*ng);

    // eigenvalues/vectors for compute
    Eigen::VectorX<COMMTP> alpha(ng),beta(ng);
    char side = 'R';
    if(compute_left_egn) side = 'B';

    // run Qz
    int sdim = 0,mm = ng;
    if constexpr (std::is_same_v<SAVETP,float>) { // save type is float
        // allocate eigenvectors
        Eigen::VectorX<COMMTP> alphai(ng);
        
        // ?gges to compute 
        LAPACKE_REAL(gges)(
            LAPACK_COL_MAJOR,'V','V','N',nullptr,
            ng,A.data(),ng,B.data(),ng,&sdim,alpha.data(),
            alphai.data(),beta.data(),Q.data(),ng,
            Z.data(),ng
        );

        LAPACKE_REAL(tgevc)(
            LAPACK_COL_MAJOR,side,'A',nullptr,
            ng,A.data(),ng,B.data(),ng,
            vl,ng,vr,ng,ng,&mm
        );
    }
    else {
        LAPACKE_CMPLX(gges)(
            LAPACK_COL_MAJOR,'V','V','N',nullptr,
            ng,(LCREALW*)A.data(),ng,(LCREALW*)B.data(),
            ng,&sdim,(LCREALW*)alpha.data(),(LCREALW*)beta.data(),
            (LCREALW*)Q.data(),ng,
            (LCREALW*)Z.data(),ng
        );

        LAPACKE_CMPLX(tgevc)(
            LAPACK_COL_MAJOR,side,'A',nullptr,
            ng,(LCREALW*)A.data(),ng,(LCREALW*)B.data(),
            ng,(LCREALW*)vl,ng,(LCREALW*)vr,ng,ng,&mm
        );
    }

    // note in surface wave dispersion, eigenvalues are always real numbers if A,B are real
    alpha = alpha.array() / beta.array();

    // compute right eigenvector
    Eigen::Map<Eigen::MatrixX<COMMTP>> VR(vr,ng,ng);
    VR = Z * VR;

    // left eigenvector if required
    if(compute_left_egn) {
        Eigen::Map<Eigen::MatrixX<COMMTP>> VL(vl,ng,ng);
        VL = Q * VL;
    }

    // save Q,Z,S,Sp matrix
    for(int j = 0; j < ng; j ++) {
    for(int i = 0; i < ng; i ++) {
        int idx = j * ng + i;
        Smat[idx] = A(i,j);
        Spmat[idx] = B(i,j);
        Qmat[idx] = Q(i,j);
        Zmat[idx] = Z(i,j);
    }}
    w = alpha;
}

/**
 * @brief QZ decomposition of matrix A and B
 * @param ng rows/cols of A, B
 * @param A,B two matrices, type = COMMTP
 * @param Qmat,Zmat,Smat,Spmat QZ matrix, where A = Q @ S @ Z.H, B = Q @ S' @ Z.H
 */
template<typename COMMTP=double,typename SAVETP=float>  void
schur_qz1(int ng,
    Eigen::MatrixX<COMMTP> &A, 
    Eigen::MatrixX<COMMTP> &B,
    std::vector<SAVETP> &Qmat,std::vector<SAVETP> &Zmat,
    std::vector<SAVETP> &Smat,std::vector<SAVETP> &Spmat
)
{
    static_assert(std::is_same_v<SAVETP,float> || 
                    std::is_same_v<SAVETP,std::complex<float>>);
    // resize all matrices
    Qmat.resize(ng*ng); Zmat.resize(ng*ng);
    Smat.resize(ng*ng); Spmat.resize(ng*ng);

    // run QZ
    int sdim = 0;
    if constexpr (std::is_same_v<SAVETP,float>){
        Eigen::VectorX<COMMTP> alphar(ng),alphai(ng),beta(ng);
        if constexpr (std::is_same_v<realw,float>) {
            LAPACKE_REAL(gges)(
                LAPACK_COL_MAJOR,'V','V','N',nullptr,
                ng,A.data(),ng,B.data(),ng,&sdim,alphar.data(),
                alphai.data(),beta.data(),Qmat.data(),ng,
                Zmat.data(),ng
            );
            memcpy(Smat.data(),A.data(),A.size()*sizeof(A(0,0)));
            memcpy(Spmat.data(),B.data(),B.size()*sizeof(B(0,0)));
        }
        else {
            Eigen::MatrixX<COMMTP> Q1(ng,ng),Z1(ng,ng);
            LAPACKE_REAL(gges)(
                LAPACK_COL_MAJOR,'V','V','N',nullptr,
                ng,A.data(),ng,B.data(),ng,&sdim,alphar.data(),
                alphai.data(),beta.data(),Q1.data(),ng,
                Z1.data(),ng
            );

            // copy to Smat/Spmat
            for(int j = 0; j < ng; j ++) {
            for(int i = 0; i < ng; i ++) {
                int idx = j * ng + i;
                Smat[idx] = A(i,j);
                Spmat[idx] = B(i,j);
                Qmat[idx] = Q1(i,j);
                Zmat[idx] = Z1(i,j);
            }}
        }
    }
    else { // save type is scmplex
        Eigen::VectorX<COMMTP> alpha(ng),beta(ng);

        if constexpr (std::is_same_v<realw,float>) {
            LAPACKE_CMPLX(gges)(
                LAPACK_COL_MAJOR,'V','V','N',nullptr,
                ng,(LCREALW*)A.data(),ng,(LCREALW*)B.data(),
                ng,&sdim,(LCREALW*)alpha.data(),(LCREALW*)beta.data(),
                (LCREALW*)Qmat.data(),ng,
                (LCREALW*)Zmat.data(),ng
            );
            memcpy(Smat.data(),A.data(),A.size()*sizeof(A(0,0)));
            memcpy(Spmat.data(),B.data(),B.size()*sizeof(B(0,0)));
        }
        else {
            Eigen::MatrixX<COMMTP> Q1(ng,ng),Z1(ng,ng);
            LAPACKE_CMPLX(gges)(
                LAPACK_COL_MAJOR,'V','V','N',nullptr,
                ng,(LCREALW*)A.data(),ng,(LCREALW*)B.data(),
                ng,&sdim,(LCREALW*)alpha.data(),(LCREALW*)beta.data(),
                (LCREALW*)Q1.data(),ng,
                (LCREALW*)Z1.data(),ng
            );

            // copy to Smat/Spmat
            for(int j = 0; j < ng; j ++) {
            for(int i = 0; i < ng; i ++) {
                int idx = j * ng + i;
                Smat[idx] = A(i,j);
                Spmat[idx] = B(i,j);
                Qmat[idx] = Q1(i,j);
                Zmat[idx] = Z1(i,j);
            }}
        } 
    }
}
    
}

#endif